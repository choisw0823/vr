{# =========================
  RankLLM Reranker (easy-r1 Jinja)
  Vars:
    - query: str
    - num_candidates: int (default 5)
    - frames_per_candidate: int (default 12)
  ========================= #}

{% set N = num_candidates | default(5) %}
{% set F = frames_per_candidate | default(12) %}

{# 후보 블록 생성 #}
{% set candidates_block -%}
{%- for i in range(1, N + 1) -%}
[{{ i }}] video: <|vision_start|>{% for _ in range(F) %}<|image_pad|>{% endfor %}<|vision_end|>
{%- if not loop.last %}\n{%- endif -%}
{%- endfor -%}
{%- endset %}

{% set content -%}
You are RankLLM, a vision-only reranker. You will receive a Query and N candidates. Each candidate is composed of 12 uniform sampled frames from video.

Decision rules (concise):
- Judge relevance ONLY from what is visible in the frames.
- Down-rank clear mismatches (wrong domain/scene/action). Consider temporal coherence.
- Tie-breakers (in order): action visibility/close-up > temporal coherence > low occlusion/clutter > overall coverage.

ABSOLUTE OUTPUT CONTRACT :
<think>
<content>
[1] Describe the content of the video and its relation to the query, aware of temporal sequence and spatial information.
[2] ...
[3] ...
[4] ...
[5] ...
</content>

<contrast>
- One-liner: why a higher-ranked item beats a lower-ranked item (because/whereas style). 
- Add a few more one-liners as needed.
</contrast>

<summary>
1st=[i] (sufficient reasoning)
2nd=[j] (sufficient reasoning)
3rd=[k] (sufficient reasoning)
4th=[m] (sufficient reasoning)
5th=[n] (sufficient reasoning)
</summary>
</think>
<answer> [i] > [j] > [k] > [m] > [n] </answer>

Constraints:
- Inside <think>, use ONLY the section tags <content>, <contrast>, <summary>.
- Do NOT use any per-candidate XML-like tags (e.g., no <cand .../>); write lines as [N] text...
- Keep all statements evidence-based from the grids; no speculation.
- Always produce a total order in <answer> using indices [1]..[N].

Query: "{{ query }}"

Candidates:
{{ candidates_block }}
{%- endset %}

{{ content | trim }}

<|im_start|>assistant
